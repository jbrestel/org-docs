#+STARTUP: indent
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE:     JBrowse Flat File Migration
#+AUTHOR:    John Brestelli
#+OPTIONS:   H:5 num:nil toc:2 p:t tags:not-in-toc ^:nil
* Workflow
- How to add the script to Reflow?
  - organism specific graph
  - create new webservice directories
  - can we test with one example organism (start of 57)?
  - all tracks (including bw) should be ready before running for real
  - should we consider splitting up ?
    - pbrowse vs jbrowse might make sense
    - update existing script to skip if file exists unless --clearCache flag is set
  - how to know when the workflow should remake the files?
    - organism changes (undo will delete all files)
    - force update if known track change (remake everything)
    - should we allow caching of files; should we be able to add tracks instead of remaking all?
* Testing
- [ ] Use the local file dumps as backend for jbrowse tracks
  - [ ] either add via front end client OR add configuration to server
* Configurations
  The file [[https://github.com/VEuPathDB/ApiCommonData/blob/master/Load/lib/xml/jbrowseQueries.xml][jbrowseQueries.xml]] defines quries to dump features.  It also contains lists property values when extra configurations are needed

** Queries
   1. Existing jbrowse queries can be found in "ApiCommonModel/Model/lib/xml/jbrowse/*"
   2. The list of tracks to be migrated can be found at the bottom of the "jbrowseQueries.xml" file (ie. we dont' need to move over all queries).
   3. jbrowseQueries will be run by the workflow.  Do not include any tuning tables!
   4. Each Query MUST return rows for Features and Subfeatures.
      - *NOTE*:  Previously jbrowse adaptor separated bulksubfeatures from features
   5. The query must retain a special MACRO for "$srcfeature_id".  This will be either an "na_sequence_id" or an "aa_sequence_id)
      - *NOTE*:  Previously jbrowse queries specified "$base_start" and "$rend".  We should not have these as the flat files will dump ALL features for each sequence
   6. Each track element MUST specify attributes for "type ["genomic","protein"] and fileSuffix ["gff", "bw", ...]
   7. Each query must return fields which corespond to GFF3 spec (order does not matter). (
      - source :: (required) name of the program that generated this feature, or the data source (database or project name)
      - feature :: (required) feature type name, e.g. Gene, Variation, Similarity.  *NOTE* jbrowse has something called "type" but not used for anything.  we should be consistent with the feature name here moving forward as we'll likely provide these files in downloads
      - startm :: (required) Start position* of the feature, with sequence numbering starting at 1.
      - end :: (required) End position* of the feature, with sequence numbering starting at 1.
      - score ::  A floating point value.
      - strand :: (required) defined as + (forward) or - (reverse).
      - frame :: One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
      - atts :: A semicolon-separated list of tag-value pairs, providing additional information about each feature.  *NOTE* when we use additional trackConfigurations (below) we need to include here values we can use as filters.  Mostly the dataset=$edName is what we want.
      - feature_id :: (required) Unique ID for the Feature
      - parent_id :: Unique ID of the parent feature
      - tstarts :: comma sep list of subfeature starts
      - blocksizes :: comma sep list of subfeature lengths

** Track Configuration (Optional)
   The Query above will be run for each configuration and ALL features will be dumped into the same output file.
      #+begin_src xml
        <!-- GenericEndFeature Example -->
	<trackConfigurations>
	  <properties>
	    <prop name="edName">tgonME49_Vinayak_FosmidEnds_clonedInsertEnds_RSRC</prop>
	    <prop name="type">fosmid</prop>
	    <prop name="sourceIdField">source_id</prop>
	    <prop name="sourceIdJoiningRegex">(.*)[^(for|rev).ab1)]</prop>
	    <prop name="spanLengthCutoff">5000</prop>
	    <prop name="includeMultipleSpans">true</prop>
	  </properties>
	</trackConfigurations>
      #+end_src

      Track Configurations can be gotten in a few different ways.  All can be found in jbrowse conf files or via webservice calls


      1. jbrowse conf files
	 #+begin_src example
	 [jbrestel@ash]$ grep -r 'Microsatellite:sts' $GUS_HOME/lib/jbrowse/*
     /var/www/PlasmoDB/plasmo.jbrestel/gus_home/lib/jbrowse/auto_generated/pfal3D7/tracks.conf
     /var/www/PlasmoDB/plasmo.jbrestel/gus_home/lib/jbrowse/pfal3D7/tracks.conf
	 #+end_src
	 

      2. configuration generated by ws calls
	 #+begin_example
     [jbrestel@ash plasmo.jbrestel]$  grep -rl 'domain:MassSpecPeptide' $PROJECT_HOME/ApiCommonModel/Model/bin/*
     /var/www/PlasmoDB/plasmo.jbrestel/project_home/ApiCommonModel/Model/bin/jbrowseOrganismSpecificPbrowseTracks
     /var/www/PlasmoDB/plasmo.jbrestel/project_home/ApiCommonModel/Model/bin/jbrowseOrganismSpecificTracks
	 #+end_example

	 This one requires some database queries to find datasets.  Look in the script to determine how to find datasets and other parameter values
      
* Script
  The script [[https://github.com/VEuPathDB/ApiCommonData/blob/master/Load/bin/jbrowseDumpAllFeatures][jbrowseDumpAllFeatures]] will loop through all tracks defined in the xml configuration and dump a file for each (per organism).  The output directory has the same structure as the workflow's webservices directory.  

    #+begin_src example
     usage: jbrowseDumpAllFeatures --output_directory $OUTPUT_DIR \\
                                   [--organism_abbrev_filter $ORG_ABBREV] \\
                                   [--replace_existing ]

    #+end_src

    - [ ] make bw files
    - [ ] check one off error for tstarts

* Front end
  JBrowse Application will read from file based Store (GFF or BW).  We will need to filter features by dataset name when appropriate. See GenericEndFeature above.

  We'll need to use filters to only show track data for one dataset.  May need a new 
** Popups
- Example POST to get wdk Table for a gene
  #+begin_example
  curl -X POST -d '{primaryKey: [{name: "source_id", value: "PF3D7_1133400"}, {name: "project_id", value: "PlasmoDB"}], attributes: [], tables: ["GOTerms"]}' -H 'Content-Type: application/json'  https://w2.plasmodb.org/plasmo/service/record-types/gene/records
  #+end_example
- Example Track
  #+begin_example
  [tracks.testGene]
  urlTemplate=PlasmoDB-54_Pfalciparum3D7_sorted.gff.gz
  storeClass=JBrowse/Store/SeqFeature/GFF3Tabix
  type=CanvasFeatures
  category=Gene Models
  key=Annotated Transcripts (UTRs in White when available) TEST
  type=NeatCanvasFeatures/View/Track/NeatFeatures
  glyph=JBrowse/View/FeatureGlyph/Gene
  unsafePopup=true
  onClick.content={geneTestDetails}
  menuTemplate+=json:{"label": "View Details", "content": "{geneTestDetails}"}
  #+end_example
- Example function to create popup from POST
 #+begin_src js
    geneTestDetails = function(track, feature, featureDiv, coreDetails) {
       var c = track.browser.config;
       container = dojo.create('div', {
           className: 'detail feature-detail feature-detail-' + track.name.replace(/\s+/g, '_').toLowerCase(),
                innerHTML: ''
              });
       var coreDetails = dojo.create('div', {
                className: 'core'
              }, container);
       var hitchCore = dojo.hitch(track, 'renderDetailField', coreDetails);
       coreDetails.innerHTML += '<h2 class="sectiontitle">Gene Details</h2>';
       var gene = feature.data.id;
       hitchCore( 'Gene', gene, feature );
       var endDetails = dojo.create('div', {
                 className: 'end'
              }, container);
       var hitchEnd = dojo.hitch(track, 'renderDetailField', endDetails);
       var goRows = new Array();
       // how to get project_id here??
       var data = {primaryKey: [{name: "source_id", value: gene}, {name: "project_id", value: "PlasmoDB"}], attributes: [], tables: ["GOTerms"]};
       c.fetchWithPost("/a/service/record-types/gene/records", data)
         .then(obj => {
                    obj.tables.GOTerms.map(x => goRows.push(c.twoColRow(x.go_id, x.ontology)));
                    hitchEnd('GOTerms', c.goTermTable(goRows), feature);
                 });
       return container;
       }          
  #+end_src

